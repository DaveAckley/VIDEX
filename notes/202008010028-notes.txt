{67}  -*- text -*- 
[0:

Sat Aug  1 00:28:53 2020 Well 'shoot', another one of the bad things
about ECLIPSE and IDEs generally is I don't have an established place
to put development notes.

So I'm starting a notes/ directory here and just using emacs
externally to populate it, although that will probably mean that
Eclipse will get mad about staleness or whatever and I'll have to be
refreshing the workspace all day long.

:0]
[1:

Sat Aug  1 00:30:35 2020 SO I'm here because it's time to get serious
about how we're going to link up our new 'teleprompter' tech to the
existing scripting system.

CURRENT STATUS:

 - The hardware is looking pretty credible.

   = Cheap 7" HDMI monitor hooked to the Dell AIO workstation by an
     HDMI<->DP cable, so we are now driving a total of three monitors
     ranging from 4K to HD to 1280x720-something.

   = Monitor is placed facing up inside the LED light ring used for
     fill and eye highlights, attached by a custom 3D printed
     bracket between a slot on the back of the monitor and and a slot
     on the base of the ring light.

   = Custom 3D printed enclosure holding a standard 5"x7" piece of
     frame glass at a 45 degree angle.  Enclosure sits directly on the
     bezel of the monitor, with a friction-fit plus gravity so it's
     not hard to remove from the monitor as a unit.
[2: Sat Aug  1 01:17:49 2020 

 - The software, on the other hand, barely exists at all.

   = We have a separate JFrame to put in the teleprompter panel

   = It does appropriate rotation/mirroring, and provides scale and x
     and y adjustments for positioning a single static text

   = And that text is currently hardcoded in the ctor..

:2]

:1]
[3:

Sat Aug  1 01:18:14 2020 So, let's have some

TODO

[5:
DONE :5] - Come on, try a spike to see if we could have two stages in two
   top-level JFrames at once.  Just try it and see how bad the
   breakage is.

[6:
DONE :6] - The world splits depending on the previous item.  So just do the
   previous item.

[7: Sat Aug  1 14:51:14 2020
DONE :7] - Do it now.
[8:

[10: Sun Aug  2 00:04:13 2020 
DONE :10] - The entire presenter screen needs to be mirrored: Can we do that in
   Java but in some half-systematic way, so that (e.g.,) mouse hits
   continue to work?

 - We need to come up with separate content for the presenter screen.


:8]   
:3]
[4:

Sat Aug  1 14:48:09 2020 OK, so, took the morning through second
sleep, but we now have a live second stage running on the presenter
screen.  It currently has the same slide deck as on the main screen,
but the display is (mostly) independent: The presenter screen handles
its own events, and we can change slides on it without affecting the
main screen display.

Let's claim and then flesh out our to-dos above.

:4]
[9:

Sun Aug  2 00:04:19 2020 OK we're taking too too long on this
presenter crab, of course.

Right now we have a second stage running on the presenter screen,
which is separately loading the same tree as the main screen.

 - Probably the simplest thing near here is to feed some flag in the
   stages so that any VO can ask whether it's on the main screen or
   the presenter screen and change its behavior as it wishes.

   (Or just add a 'Stage getStage()' to the VO interface.  Is it
   already there?[11: Sun Aug  2 00:20:20 2020 No, we pass a Stage arg
   to updateVO, but not to drawVO.  But drawVO gets a VOGraphics2D,
   which we might be able to add a getStage() method to..[12: Sun Aug
   2 00:53:32 2020 OK, now there's 'Stage VOGraphics.getStage()'
   :12] :11])

   That would allow us to change to displaying notes vs slides, and
   supply 'teleprompter scrolling' rider behavior.  The
   main-vs-presenter behavioral differences will be scattered all over
   hail and creation, but..

 - An alternative would be to diverge during the loading so we end up
   with distinctly different stage contents, like with BasicSlides on
   the main screen but BasicNoteSlides on the presenter screen.

   That seems to involve a lot more design, and more understanding of
   the existing codebase to support such design.

:9]
[13:

Sun Aug  2 05:04:48 2020 Well, so we went with a Stage.Purpose
getPurpose() interface, so far with choices of MAIN_SCREEN and
PRESENTER_SCREEN.

And now we have notes text displaying on the presenter screen, and the
main slide on the main screen.  Fine.  But so far we've just diverted
at the level of the text that gets rendered -- mNotesString vs
mTextString, with control splitting in BasicSlide.updateThisVO.

But we need to divert a lot more than just that.  We need a differen
Pose, for example, and different colors, and we're going to need
different rider behavior as well.  We're going to do all that with
foggen switch statements all over hail and creation?

Could we subclass BasicSlide instead?  BasicSlideMain vs
BasicSlideNotes?  But when we're loading these things we're reading
the parameters from text template files.

Could we expand genscript template generation instead?  So it
generates like an entirely different save/load directory for the
presenter stage?  Or leaves them all in one directory but generates
two roots, one for each stage?  Then we could have notes templates
with different colors and poses and scroll rates and so forth.

Something like that seems better.[14:

Sun Aug  2 05:37:30 2020 But I'm tired.  Second sleep.

:14]

:13]
[15:

Sun Aug  2 10:23:16 2020 So how would a genscript expansion go?

Right now we have note text landing in $slideNotes{$index}, and then
going to $SUBS{'CUR_NOTES_TEXT'} during genSlideFromText.

[16:

Sun Aug  2 10:29:20 2020 So, we could add a mNotesSlide member to
BasicSlide, and generate that in the SLIDE.oio.tmpl template with like
#(aux:mNotesSlide), and so forth.  That would get us access to the
notes slide from the main screen, but it wouldn't get the notes slide
itself up onto the presenter screen.

How does the 'aux' system work, again?[17:

Sun Aug  2 10:49:36 2020 There's $SUBS{'BASE_AUX_ID'}, and it's
incremented and used whenever an 'aux:FOO' is encountered for the
first time.

[18:

Sun Aug  2 11:06:36 2020 How is the root threading set up?[19:

Sun Aug  2 11:07:14 2020 DECK.oio.tmpl has a BasicSlideDeck hardcoded
to #11, and uses '#(SLIDES)' as its mVO value.  genscript
$SUBS{'SLIDES'} accumulates all the slide ids allocated in
genSlideFromText calls.  We could parallel that for notes.

And the Java code eventually picks up the hardcoded #11?  Let's
check. [20:

Sun Aug  2 11:43:33 2020 Twisted..  We for file 0.oio only, we call
OIOLoad.processTop(File) which looks at the first token, demands that
it's an onum, and sets mTopOnum to it (horking if mTopOnum is already
set).  Later, OIOLoad uses mTopOnum to find the OIOAble to return, and
that becomes the mLoadedRoot in OIOLoadConfiguration.  Finally,
mLoadedRoot becomes a child of OIOLoadStage.mRoot, which is, I think,
the 'real root'.

So not completely clear how to establish the 'notes root'.  Add
mNotesRoot to BasicSlideDeck, genscript it in, then have OIOLoad check
for it and pass it off to the notes stage.

That means we have to _not_ do the loading on the notes side.  But
we've already split the flows at that point?


:20]

:19]

:18]

:17]

:16]

:15]
[21:

Sat Oct 10 14:08:30 2020 OK so here we are again, trying to get
'teleprompter notes' working in VIDEX.

Reviewing these notes for clues what the plan was/should be.

:21]
[22:

Sat Oct 10 14:10:42 2020 OK, so :4: is claiming we got to a second
stage running on the presenter screen, and the issue was how to get
content for the presenter screen.

:13: took us down the road of splitting the display processing based
on which stage we're in, but it looked hard to extend to additional
variant properties, and it was starting to think about alternatives
based on splitting BasicSlide into something including
BasicSlideNotes.

:15: started down that road, and :16: postulated
BasicSlide.mNotesSlide as a way to link slides on the main screen to
their notes counterpart on the presenter screen.

:19: and :20: think about ways to get the 'notes root' associated with
the presenter screen, and then it all just quits.

So that's our frontier.

:20: talks about having 'split the flows', which I believe means we've
actually loaded the whole oio code twice -- once for each stage -- but
is that true?  Can we find that split and remind ourself what's what?

[23:

Sat Oct 10 15:06:37 2020

 - Our current main() is in ..drivers.OIOLoadDriver2020

..aah and there's the split right there, apparently:

            OIOLoad oio = new OIOLoad(basedir, omap);
            OIOLoad oioNotes = new OIOLoad(basedir, omap);
  ..
            mConfiguration = new OIOLoadConfiguration(oio);
            mNotesConfiguration = new OIOLoadNotesConfiguration(oioNotes);
            mWorld = mConfiguration.buildWorld(mConfiguration);
            if (mWorld==null)
                throw new Exception("World construction failed");
            mNotesWorld = mNotesConfiguration.buildNotesWorld(mNotesConfiguration);
  ..

[24:

Sat Oct 10 15:23:55 2020 So what actually is the problem?  mNotesWorld
from mNotesConfiguration from buildNotesWorld?  Why isn't everything
completely separate?  Let's watch some of it, I guess.[25:

Sat Oct 10 15:39:43 2020 So have been watching it.  mNotesWorld ends
up a completely separate thing with a separate map of onums and so
forth, so there's actually two copies of oio, say, #3501, in the
system as a whole.  So the current idea of having
BasicSlide.mNotesSlide pointing at the notes slide is a little awkward
because the presenter screen has all the BasicSlide's too.  The 'notes
root' is going to be the same as the 'real' root, but getting looked
up in a different onum map.

Could we keep changing the 'effective' onum root, somehow?  When a
BasicSlide gets presented on the main screen, we take its mNotesSlide
and stuff it into the presenter screen root?  Or just have some
screen-aware display hack that forwards display requests from
BasicSlides to BasicSlide.mNotesSlide when we're on the presenter
screen?  And then couple slide changes on the main screen to the
analogous change on the presenter screen?
[26:

Sat Oct 10 16:04:03 2020 OK, so oios actually were getting displayed
on the presenter screen, and differentially because of that, but they
were all shrunk down and invisible, and they don't advance when the
main screen advances because they're in a completely separate world.

So we can see '-not yet-'s on the presenter screen (although they are
upside down and backwards at the moment).
[27:

Sat Oct 10 16:19:44 2020 OK, more notes:

 - MirrorPanel exists but is currently unused.

 - Instead, there's this code in OIOLoadNotesConfiguration

  ..       if (!reloadIfNeeded()) {
                StagePanel sp = this.getStagePanel();
                if (sp != null)
                    sp.setPanelScale(new Point2D.Double(1,-1));

                mRoot.updateVO(this);
            }
 
which (now), correctly flips just the Y axis, and not the X axis --
and now we have the '-not yet-'s appearing upright and legible on the
presenter screen.
[28:

Sat Oct 10 16:23:34 2020 So.  How could we couple main screen slide
changes to the presenter screen?  It's the slide deck that knows which
slide is really being 'shown' (even though all the slides are on the
screen). [29:

Sat Oct 10 16:35:47 2020 So BasicSlideDeck.gotoSlide changes the
presented slide.  Not clear how to hook out from that.

Perhaps we could hook in rather than out -- have the presenter screen
BasicSlideDeck somehow know to track the mCurrentSlide on its main
screen counterpart.  At least that puts the grossness in the hacky
extra stuff.[30:

Sat Oct 10 16:38:45 2020 Having BasicSlideDeckNotes (which we
currently do not) could maybe also help to get differential css, via
BasicSlideDeck(Notes).checkLoadCSS().[31:

Sat Oct 10 16:40:00 2020 So we have both updateThisVO and drawThisVO
available as hooks in BasicSlideDeck.

We're going to need some object-to-rule-them-all letting us cross
between the two worlds.[32:

Sat Oct 10 16:41:58 2020 I guess at the moment OIOLoadDriver2020 is
that uber-object.  It's the one with:

 .. private Configuration mConfiguration;
    private Configuration mNotesConfiguration;

    private World mWorld;
    private World mNotesWorld;
 ..

So that would be a natural place to split out a 'universe' interface
or base class -- a thing capable of supporting multiple worlds and
navigating between them.
[33:

Sat Oct 10 16:48:28 2020 That's a place to pick up, I think.  But now
it's just about time for cocktails.

:33]
:32]

:31]

:30]

:29]

:28]
:27]
:26]

:25]

:24]

:23]

:22]
[34:

Sun Oct 11 01:12:56 2020 OK let's try making Universe.

[35: Sun Oct 11 03:33:17 2020
DONE :35] - Supports multiple named worlds, for creation and lookup

[36: Doesn't care one way or the other, so moot; let's say
DONE :36] - Supports common or separate args for loading (we'll start using
   common)

[37:
DONE :37] - And, let's try to say: That's all.

:34]
[38:

Sun Oct 11 03:33:46 2020 So okay, Worlds now have names and access to
the universe.[39:

Sun Oct 11 04:09:32 2020 I guess let's see if we can get the
BasicSlideDeck of MAIN World to control the BasicSlideDeck of the
PRESENTER World..[40:

Sun Oct 11 04:31:02 2020 OK and how do we get from a World to its
contained BasicSlideDeck?  It's a long way away:

 - A World can have multiple Stages

 - Each Stage has a StageVO getRoot()

 - A StageVO is a StandardVO which has a general tree of VO children

 - The BasicSlideDeck is a 'few more levels' down from the StageVO.
   I'm not even sure how many.

So do we walk the tree?  Walk it each time we need it?  Cache a set of
onums?  Are the onums going to be the same for sure or different for
sure? [41:

Sun Oct 11 04:40:02 2020 It looks like the onums are identical..  So
how do we look up an onum in a world?
[42:

Sun Oct 11 04:42:29 2020 Well, we can get an iterator to the Stages
via World.iterator(), or we can call World.forEach() with some lambda
Stage Consumer.

[43:

Sun Oct 11 04:45:38 2020 We need to get our hands on the OIOLoad
object; that's where the mOnumMap lives.[44:

Sun Oct 11 04:46:32 2020 And OIOLoadConfiguration has a reference to
it in its mLoader.[45:

Sun Oct 11 04:47:47 2020 And the OIOLoadWorld ctor takes an
OIOLoadConfiguration reference, which it passes to its super,
StandardWorld, and StandardWorld.mConfig holds the ref.[46:

Sun Oct 11 04:49:16 2020 And StandardWorld's World.getConfiguration()
method returns it.

So:

     World w = ..;
     Configuration config = w.getConfiguration();
     if (!(config instanceof OIOLoadConfiguration)) boom;
     OIOLoadConfiguration olc = (OIOLoadConfiguration) config;
     OIOLoad loader = olc.getLoader();
     OIOAbleGlobalMap omap = loader.getMap();
     OIOAble oa = omap.get(ONUMOFINTEREST);
     if (oa == null) deal;
     if (!(oa instanceof BasicSlideDeck)) deal;
     BasicSlideDeck bsd = (BasicSlideDeck) oa;
     bsd.gotoSlidePublically(SLIDENUMBER)

Glarrgh. Well it might work.
[47:

Sun Oct 11 05:08:17 2020 Well, so now we have the presenter screen
slide deck following the moves on the main screen.

It's terribly hacky but it still does feel like progress.

Issues:

 - We have a OIOLoadConfiguration vs OIOLoadNotesConfiguration
   distinction that can probably go away, and if it doesn't, at least
   they should be refactored to have an immediate common base.

 - How do we start changing appearance details more systematically?
   We want:
   = Smaller font
   = Greyer font
   = Faster slide changing
   = Pose adjustments

 - And eventually we (have been thinking we'd) want to direct commands
   to the presenter screen specifically, for example to page or scroll
   the notes without affecting the main screen. [49: Sun Oct 11 07:18:27 2020 Also:

 - At the moment genscript is putting the notes into a separate
   object, but the code wants to look for a mNotesString member on
   BasicSlide, so the genscript notes text is not currently getting
   visualized at all.

:49]
[48:

Sun Oct 11 06:55:51 2020 Could we have more support from genscript,
like for World-specific templates?  CSS.PRESENTER.tmpl or whatever?
[50:

Sun Oct 11 11:48:38 2020 Poking through stuff, it looks at least
plausible that we could extend OIOCompiler to stash a world name at
ctor-time, and pass that down into Lexer at OIOCompiler.compile(..)
time, and then make some 'preprocessor' syntax for some kind of
'if-world' token.

Like say '?'.  We could insist on a TT_WORD following a '?', and then
check if that word matches the OIOCompiler.mWorldName.  If it matches,
then the '?' plus the TT_WORD just vanishes.  If it doesn't match,
then the '?' plus the TT_WORD plus the rest of the line vanishes.

Could also have perhaps '!' mean eat line if the names do match, if we
wanted it.

That would get us a minimal kind of 'conditional compilation' at the
oio level -- sufficient to handle variant poses, for example, in a
vaguely localized manner.

It would not, though, address the issue of how to get variant css out
of .css files, the contents of which we don't currently parse at all,
by ourselves.

[51: Sun Oct 11 12:03:26 2020 It could also be enough to handle notes
vs regular html?  Except no, the html is done with non-inline files
just like the .css stuff.  OIOLoad.mOutOfLineContent is currently

 { ONUM -> { EXTENSION -> byte array } }

for all the files in the load dir whose first 'piece' is a lex
number.  [52:

Sun Oct 11 12:16:38 2020 Now, at this point, OIOLoad.decomposeFileName
will hork and skip a filename like "3501.PRESENTER.html", but we could
extend it if we wanted.  Then callers would need to deal with that.
Of which there are currently..  [53: Sun Oct 11 12:19:05 2020
..precisely one caller, so that's not so bad I guess.

Could extend mOutOfLineContent to

  { ONUM -> { EXTENSION -> { WORLD -> byte array } } }

with like an empty string for an unspecified world?  Then search for
world-specific first but fall back to unspecified?  How many
mOutOfLineContent consumers are there?[54:

Sun Oct 11 12:21:47 2020 Just the OIOLoad.considerFile that we already
looked at, plus OIOLoad.getOutOfLineContentIfAnyAsByteArray, which
would be where the world-specific-or-fallback behavior would happen,
presumably.
[55:

Sun Oct 11 12:23:45 2020 OK, let's go for it.

TODO

[59: Sun Oct 11 13:52:33 2020 I think,
DONE :59] - Extend mOutOfLineContent, getOutOfLineContentIfAnyAsByteArray,
   considerFile, and decomposeFileName as directed above.

[60: Sun Oct 11 14:56:45 2020 A cut anyway
DONE :60] - Redo genscript to generate slide html code into like
   3501.MAIN.html, and slide notes into 3501.PRESENTER.html.

[61: Sun Oct 11 14:56:55 2020
DONE :61] - Demonstrate variant content appearing on the main screen vs the
   presenter screen.

[65: Sun Oct 11 16:52:54 2020 Let's not mess with Lexer today, and say
DONE :65] - Return here to consider finalizing the Lexer level conditional
   stuff.

[56: Sun Oct 11 12:28:10 2020 GO GO GO
[57:

Sun Oct 11 12:51:48 2020 Getting there.  Issue in construction order:
Currently OIOLoad is built before OIOLoadConfiguration, but the world
name isn't known until OIOLoadConfiguration time, so we can't supply
it to the OIOLoad ctor, even though by rights it ought to be final.

 - OIOLoadConfiguration.mLoader is final..

 - StandardWorld.mWorldName is final..

Could we build the loader inside OIOLoadConfiguration?  And I guess
give the world name to OIOLoadConfiguration too?  We should push the
world name deeper into the configuration, presumably.[58:

Sun Oct 11 13:49:19 2020 OK well we're building clean again.

[62:

Sun Oct 11 14:57:16 2020 So, getting there.  Now have notes content on
the PRESENTER screen and regular content on the MAIN screen, and they
change slides together.  And, we make a toplevel window for the MAIN
screen but not the PRESENTER screen.

Problem at the moment is we don't have the PRESENTER screen flipped
upside-down anymore, because the construction is much more generic
now.

Where was that flipping happening?  Some Stage thing?[63:

Sun Oct 11 15:10:14 2020 It's in OIOLoadConfiguration.updateStage(),
via a call on StagePanel.setPanelScale.. which is kind of a gross
place for it.  Should we push it into the configuration?

:63]

:62]
:58]

:57]:56]

:55]
:54]

:53]

:52]



:51]

:50]
:48]

:47]
:46]

:45]

:44]



:43]

:42]
:41]

:40]

:39]

:38]
[64:

Sun Oct 11 16:50:22 2020 Well, really getting there now:

 - PRESENTER screen is flipped and scaled a bit

 - PRESENTER screen starts in the right place and size (YAY)

:64]
[66:

Sun Oct 11 16:53:26 2020 Let's try actually writing some script/notes
here and see how all this really feels.

:66]
